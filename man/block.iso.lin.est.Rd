% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/block.iso.lin.est.R
\name{block.iso.lin.est}
\alias{block.iso.lin.est}
\title{Nonparametric LSE for L-Lipschitz function in L2 norm over the 2d lattice.}
\usage{
block.iso.lin.est(x, y, L0 = 100, run.itr = TRUE, ...)
}
\arguments{
\item{x}{\code{n1 x n2} numeric matrix of observed covariates. Each element
of this matrix is a list of vector. For instance, the (i,j)th element of the
matrix corresponds to x\link{i, j} = list(c(a, b)), which takes the value (a, b).}

\item{y}{\code{n1 x n2} numeric matrix of observed responses.}

\item{L0}{The upper bound of the interval of L parameters to search over
the interval is in the form of \link{-L0 x log10(n), L0 x log10(n)}.
In practice, this should be a large enough constant so the set contains
the true Lipschitz parameter L.}

\item{run.itr}{A Boolean parameter for selecting iterative optimization or
joint optimization. The iterative optimization gives an approximated minimum
but it tends to be faster. Default is TRUE.}

\item{...}{Additional control parameters}
}
\value{
An object with S3 class \code{block.iso.lin.est}.
}
\description{
The implementation is based on the fixed design setting and currently does
not support random designs. The core implementation is based on block max-min
algorithm proposed by Deng and Zhang (2020), which runs O(n^3). Since
we have to run block max-min algorithm inside of the numerical optimizer,
this algorithm can take long time to complete.
}
\examples{
# creates sample
n1 <- 10; n2 <- 10
y <- matrix(rep(0, n1*n2), nrow = n1)
x <- matrix(rep(list(), n1*n2),nrow = n1, ncol =n2)
for (i in 1:n1){
  for (j in 1:n2){
    y[i,j] <- sin(10*norm(c(i/n1, j/n2), "2")) + rnorm(1, 0, 0.1)
    x[i,j] <- list(c(i/n1, j/n2))
  }
}
res.est <- block.iso.lin.est(x, y)
y.hat <- predict(res.est) # estimated values over the grid.
}
